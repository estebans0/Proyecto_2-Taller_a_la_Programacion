# Documentación del segundo proyecto de Taller a la Programación :space_invader::joystick:
## Introducción
La presente sección escrita tiene como objetivo la documentación del segundo proyecto del curso de Taller a la Programación (CE 1102) de la carrera de Ingeniería de Computadores. Dicho proyecto, análogo al primero, consistirá en el desarrollo de un videojuego, la diferencia radica en que, para esta ocasión, el videojuego tendrá como objetivos principales el esquivar una serie de elementos que aparecerán en pantalla y el sobrevivir durante una cantidad de tiempo determinada, evitando a toda costa ser golpeados por los elementos antes mencionados para así alcanzar la máxima puntuación posible. Al igual que para el primer proyecto, la temática del videojuego será el espacio, por lo que los elementos a esquivar estarán representados por asteroides, mientras que el sprite que el jugador controlará será una nave espacial. En cuanto a lo que es el desarrollo del videojuego como tal, nuevamente se hará uso de la biblioteca Tkinter para el desarrollo de la interfaz gráfica; un par de módulos propios del lenguaje de programación de Python que permitan tomar el tiempo ("Time") y que permitan generar números de manera aleatoria ("Random"); y la biblioteca de sonido "mixer" perteneciente al módulo de "Pygame", para la implementación de música y sonidos. Por último, algo a resaltar es que, para esta ocasión, se hará uso del algoritmo de ordenamiento Quicksort, con el cual se administrarán los puntajes obtenidos por el jugador durante sus partidas. 

Esta documentación estará estructurado de la siguiente manera: Sección de códigos importantes, resultados finales, ensayo sobre la importancia de la ética, equidad y el trabajo en equipo y un cronograma en el que se detallará la manera en la que se desarrolló el proyecto. En la primera sección mencionada se incluirán fragmentos de código de importancia para el funcionamiento del videojuego, además de una breve explicación de los mismos, siendo quizá los algoritmos que se encargarán del movimiento tanto del jugador como de los elementos en pantalla y el algoritmo de ordenamiento Quicksort los más importantes de la sección. Para la segunda sección del trabajo se incluirán screenshots del videojuego en funcionamiento, con ello, se mostrarán las mecánicas de juego más importantes, además, estas imágenes estarán complementadas por una explicación sobre la mecánica mostrada. Para la tercera sección mencionada, se redactará un ensayo con una extensión de una página en el que se hablará un poco sobre la importancia de la ética, la equidad y el trabajo en equipo a la hora de ejercer una profesión. Por último, pero no menos importante, se incluirá un cronograma en el que se observará la manera en la que las tareas fueran distribuidas entre los integrantes del grupo con tal de ejemplificar un poco cómo se trabajó y se desarrolló el proyecto. 

## Secciones de código importantes
En esta sección, se explicará el funcionamiento de los métodos fundamentales para la correcta ejecución del videojuego.
### Funciones de movimiento
- Funciones del movimiento de la nave:
  
 __Clase "Jugador"__:
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_derecho(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __derecha__. |
 | movimiento_izquierdo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __izquierda__. |
 | movimiento_arriba(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __arriba__. |
 | movimiento_abajo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __abajo__. |
 
 __Es importante saber que las posiciones sobre los ejes son atributos propios de la clase "Jugador" a los que se accede para poder hacer las sumas o restas, según el caso.__
 
 Los métodos descritos anteriormente trabajan en conjunto con la función ``renderizacion`` que, tal y como su nombre lo indica, se encarga de renderizar o de dibujar sobre el lienzo de la pantalla del nivel (el "canvas" del nivel) al jugador. Dentro de la función ``renderizacion`` se encuentran las siguientes funciones relacionadas al movimiento del jugador:
 
 __Función "renderizacion":__
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_hacia_derecha(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_derecho`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador más los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_derecho``. Luego, dentro de la función ``movimiento_hacia_derecha``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_derecho``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __derecha__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_derecho``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_izquierda(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_izquierdo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_izquierdo``. Luego, dentro de la función ``movimiento_hacia_izquierda``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_izquierdo``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __izquierda__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_izquierdo``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_arriba(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_arriba`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_arriba``. Luego, dentro de la función ``movimiento_hacia_arriba``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_arriba``) que permitirán el movimiento del objeto, en este caso la nave, hacia __arriba__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_arriba``, esta función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_abajo(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_abajo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador más los 10 pixeles introducidos como argumento en la función ``movimiento_abajo``. Luego, dentro de la función ``movimiento_hacia_abajo``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_abajo``) que permitirán el movimiento del objeto, en este caso la nave, hacia __abajo__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_abajo``, el mismo retornará 0, causando que el "sprite" __no se mueva__. |
 
 Note que en las funciones antes descritas, el argumento que estas reciben siempre es el mismo: "event". La biblioteca "Tkinter" nos permite trabajar con eventos que van desde tocar una tecla hasta hacer un "click", con "event" se refiere justamente a ese tipo de eventos. A través del método propio de "Tkinter" ``.bind`` es posible asignarle a una función un determinado evento. Cuando ese evento se de, causará una llamada a la función a la que esté ligada, por ejemplo, para el caso de la función ``movimiento_hacia_abajo`` el evento asignado es el "tocar la flecha que apunta hacia abajo del teclado", cuando se lleve a cabo esta acción, la función ``movimiento_hacia_abajo`` será llamada, permitiendo así el movimiento de la nave hacia a abajo cuando se toque esta tecla.
 
 También es importante saber que la función ``renderizacion`` no solo se encarga de renderizar/dibujar en pantalla al jugador, también tiene la tarea de cargar y renderizar los asteroides que aparecen en pantalla, y los "labels" que contienen información importante como el puntaje obtenido, la cantidad de vidas del jugador, el tiempo transcurrido y el nivel en el que se está. En el caso de los asteroides, como la cantidad de estos varía según el nivel, fue necesario implementar un par de condiciones que se encargarán de verificar el nivel en el que se está y con base a ello, cargar la cantidad de asteroides que corresponden al nivel. Por último, pero no menos importante, en el caso de los "labels" no hizo falta poner ninguna condición, pues estas etiquetas se deberán renderizar, por igual, en cada nivel. 

- Función del movimiento de los asteroides:

 La función encargada del movimiento de los obstaculos es el método ``movimiento_asteroides``, que se recibe como argumentos tres cosas: El nivel, que sería un objeto de alguna de las 3 clases de nivel que hay en el que se crearía el nivel como tal. Teniendo este objeto es posible acceder a los asteroides y a los atributos que construyen a estos últimos. La función también recibe la pantalla y el lienzo del nivel sobre el que se está, esto obviamente para lograr que los asteroides se muevan dentro de la pantalla del nivel en el que se está jugando. Cabe resaltar que es función también tiene un par de condiciones que se encargan de verificar el número de nivel en el que se está, pues tal y como se especificó antes, la cantidad de asteroides en pantalla avría según el nivel, y por lo tanto, la cantidad de asteroides a mover también varía. Por último, hay que resaltar que la lógica detrás del código que compone a esta función es exactamente el mismo para todos los asteroides, literalmente, lo único que cambia es el asteroide al que accedemos (puede ser el ``asteroide_1``, el ``asteroide_2``, el ``asteroide_3`` etc.).
 
 __Explicación, movimiento de los asteroides (es la misma lógica para todos los asteroides):__
 
 Después de haber verificado el nivel en el que se está, la función se encarga de ir realizando las operaciones que se encargan de darle movimiento a cada asteroide. El código que permite esto está estructurado de la siguiente manera: Un bloque se encarga de modificar la posición y dirección en el eje "x" que el asteroide lleva, mientras que el otro bloque hace exactamente lo mismo, pero para el eje "y". Cabe resaltar que tanto la posición como la dirección de los ejes son atributos propios de la clase "Asteroide", los cuales, dependiendo de las coordenadas en las que el asteroide se encuentre en el momento, se modificarán de una u otra manera.
 
 Primero, lo que la función hará será darle una trayectoria base al asteroide, este comenzará a moverse normalmente; mientras el asteroide se mueve, la función va a verificando que la posición actual tanto en el eje "x" como en el eje "y" no exceda los límites establecidos en las condiciones creadas para cada eje. En el momento en el que el asteroide exceda alguno de estos límites, la dirección que el asteroide lleva sobre ese eje cambiará, causando que la cantidad predeterminada de pixeles que el obstáculo se mueve (10 pixeles) se resten o se sumen de la posición en el eje "x" o "y" actual del asteroide, según corresponda, causando así que el asteroide se mueva hacia la derecha, izquierda, arriba o abajo, dependiendo de la posición que se haya modificado y de si se sumó o se restó. Cabe resaltar que el valor predeterminado de la dirección tanto en el eje "x" como en el "y" es 1, lo que causa que la dirección cambie es el signo delante de ese 1. Por ejemplo, si hablamos sobre el movimiento que se da en el eje “x”, si el 1 fuese negativo, entonces, cuando se haga la multiplicación que nos da el valor final que habrá que sumarle o restarle a la posición actual que lleva el asteroide sobre el eje “x”, como el 1 es negativo, entonces, al multiplicar esa dirección por los 10 pixeles que se mueve el asteroide, la cantidad se restará de la posición en el eje "x" (pues por el signo del 1, el producto será negativo) lo que generará que el asteroide se mueva hacia la izquierda, mientras que en el caso del eje “y”, esta resta permitirá el movimiento hacia arriba. Por otro lado, si el 1 fuese positivo, entonces la cantidad de pixeles en lugar de restarse de la posición actual del asteroide, se suman, permitiendo así un movimiento a la derecha (en el caso del eje “x”) y un movimiento hacia abajo (en el caso del eje “y”). Ahora, el movimiento de los asteroides va más allá de esto, pues la trayectoria que la función logra emular no sigue ningún patrón, es completamente aleatoria para todos y cada uno de los asteroides en pantalla.
 
 Básicamente, en el bloque que se encarga del movimiento sobre el eje “x” hay dos condiciones, una que marca el límite máximo al que el asteroide puede llegar por la derecha y otra que marca el límite mínimo al que el asteroide puede llegar por la izquierda. En el caso de la primera condición, si el asteroide excede el límite establecido, entonces la dirección que lleva sobre el eje “x” cambiará a ser -1 para que la nave se comience a mover hacia la izquierda, sin embargo, la dirección que lleva en ese momento sobre el eje “y” cambia, de manera aleatoria, a un número entre 1 y -1 (ambos números obviamente también están incluidos). Esta aleatoriedad se logra gracias al módulo “random”, el cual, a través del método ``random.randint``, permite establecer un rango de números. El método podrá retornar, de manera aleatoria, un número dentro del rango establecido, en el caso de la función de movimiento de los asteroides, como era de esperar, el rango está definido entre -1 y 1, por lo que cuando el asteroide excede el límite establecido por la derecha, aparte de cambiarse la dirección del movimiento horizontal a -1, la dirección del movimiento vertical cambia aleatoriamente, haciendo que el asteroide se pueda mover hacia abajo o hacia arriba de manera aleatoria. Lo mismo ocurre con el límite del lado izquierdo, si el asteroide se pasa de este límite, la dirección que lleva sobre el eje “x” cambia a 1, por lo que el asteroide se comienza a mover hacia la derecha nuevamente, pero la dirección del eje “y” cambia aleatoriamente a un número entre -1 y 1, logrando así el mismo movimiento descrito en líneas anteriores. Para el caso del movimiento sobre el eje “y”, tenemos también dos condiciones que establecen dos límites distintos: Una condición establece el límite máximo al que el asteroide puede llegar por debajo, mientras que la otra establece el límite mínimo al que el asteroide puede llegar por arriba. Si el asteroide excede el límite establecido por abajo, la dirección sobre el eje “y” pasa a ser -1 para que la cantidad de pixeles que el asteroide se mueve se resten de la posición actual en el eje “y” del asteroide para que así este comience a subir. Por otro lado, la dirección que lleva sobre el eje “x” termina tomando un valor aleatorio entre -1 y 1, por lo que el asteroide puede llegar a moverse hacia la derecha o hacia la izquierda, dependiendo del valor que sea retornado por el método ``random.radint``. Lo mismo ocurre para el límite establecido por arriba, si el asteroide se pasa de este límite, la dirección sobre el eje “y” cambia a 1, causando así que la cantidad de pixeles que el asteroide se mueve se sumen, por lo que el asteroide comienza a bajar. A su vez, la dirección que el asteroide lleva en el eje “x” cambia nuevamente a un valor aleatorio entre 1 y -1, causando así que el asteroide se pueda mover hacia la derecha o hacia la izquierda. Ahora, la razón por la que el asteroide puede moverse de manera incluso diagonal es porque todos los bloques de código antes descritos trabajan en conjunto, por lo que el asteroide adquiere la capacidad de emular todo tipo de trayectorias de manera aleatoria. Por último, es importante resaltar que todos y cada uno de los asteroides de los niveles utilizan exactamente el mismo algoritmo para lograr el movimiento aleatorio.   

 ## Resultados
 
