# Documentación del segundo proyecto de Taller a la Programación :space_invader::joystick:
## Introducción
La presente sección escrita tiene como objetivo la documentación del segundo proyecto del curso de Taller a la Programación (CE 1102) de la carrera de Ingeniería de Computadores. Dicho proyecto, análogo al primero, consistirá en el desarrollo de un videojuego, la diferencia radica en que, para esta ocasión, el videojuego tendrá como objetivos principales el esquivar una serie de elementos que aparecerán en pantalla y el sobrevivir durante una cantidad de tiempo determinada, evitando a toda costa ser golpeados por los elementos antes mencionados para así alcanzar la máxima puntuación posible. Al igual que para el primer proyecto, la temática del videojuego será el espacio, por lo que los elementos a esquivar estarán representados por asteroides, mientras que el sprite que el jugador controlará será una nave espacial. En cuanto a lo que es el desarrollo del videojuego como tal, nuevamente se hará uso de la biblioteca Tkinter para el desarrollo de la interfaz gráfica; un par de módulos propios del lenguaje de programación de Python que permitan tomar el tiempo ("Time") y que permitan generar números de manera aleatoria ("Random"); y la biblioteca de sonido "mixer" perteneciente al módulo de "Pygame", para la implementación de música y sonidos. Por último, algo a resaltar es que, para esta ocasión, se hará uso del algoritmo de ordenamiento Quicksort, con el cual se administrarán los puntajes obtenidos por el jugador durante sus partidas. 

Esta documentación estará estructurado de la siguiente manera: Sección de códigos importantes, resultados finales, ensayo sobre la importancia de la ética, equidad y el trabajo en equipo y un cronograma en el que se detallará la manera en la que se desarrolló el proyecto. En la primera sección mencionada se incluirán fragmentos de código de importancia para el funcionamiento del videojuego, además de una breve explicación de los mismos, siendo quizá los algoritmos que se encargarán del movimiento tanto del jugador como de los elementos en pantalla y el algoritmo de ordenamiento Quicksort los más importantes de la sección. Para la segunda sección del trabajo se incluirán screenshots del videojuego en funcionamiento, con ello, se mostrarán las mecánicas de juego más importantes, además, estas imágenes estarán complementadas por una explicación sobre la mecánica mostrada. Para la tercera sección mencionada, se redactará un ensayo con una extensión de una página en el que se hablará un poco sobre la importancia de la ética, la equidad y el trabajo en equipo a la hora de ejercer una profesión. Por último, pero no menos importante, se incluirá un cronograma en el que se observará la manera en la que las tareas fueran distribuidas entre los integrantes del grupo con tal de ejemplificar un poco cómo se trabajó y se desarrolló el proyecto. 

## Secciones de código importantes
En esta sección, se explicará el funcionamiento de los métodos fundamentales para la correcta ejecución del videojuego.
### Funciones de movimiento
- Funciones del movimiento de la nave:
  
 __Clase "Jugador"__:
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_derecho(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __derecha__. |
 | movimiento_izquierdo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __izquierda__. |
 | movimiento_arriba(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __arriba__. |
 | movimiento_abajo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __abajo__. |
 
 __Es importante saber que las posiciones sobre los ejes son atributos propios de la clase "Jugador" a los que se accede para poder hacer las sumas o restas, según el caso.__
 
 Los métodos descritos anteriormente trabajan en conjunto con la función ``renderizacion`` que, tal y como su nombre lo indica, se encarga de renderizar o de dibujar sobre el lienzo de la pantalla del nivel (el "canvas" del nivel) al jugador. Dentro de la función ``renderizacion`` se encuentran las siguientes funciones relacionadas al movimiento del jugador:
 
 __Función "renderizacion":__
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_hacia_derecha(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_derecho`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador más los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_derecho``. Luego, dentro de la función ``movimiento_hacia_derecha``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_derecho``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __derecha__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_derecho``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_izquierda(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_izquierdo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_izquierdo``. Luego, dentro de la función ``movimiento_hacia_izquierda``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_izquierdo``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __izquierda__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_izquierdo``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_arriba(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_arriba`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_arriba``. Luego, dentro de la función ``movimiento_hacia_arriba``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_arriba``) que permitirán el movimiento del objeto, en este caso la nave, hacia __arriba__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_arriba``, esta función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_abajo(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_abajo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador más los 10 pixeles introducidos como argumento en la función ``movimiento_abajo``. Luego, dentro de la función ``movimiento_hacia_abajo``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_abajo``) que permitirán el movimiento del objeto, en este caso la nave, hacia __abajo__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_abajo``, el mismo retornará 0, causando que el "sprite" __no se mueva__. |
 
 Note que en las funciones antes descritas, el argumento que estas reciben siempre es el mismo: "event". La biblioteca "Tkinter" nos permite trabajar con eventos que van desde tocar una tecla hasta hacer un "click", con "event" se refiere justamente a ese tipo de eventos. A través del método propio de "Tkinter" ``.bind`` es posible asignarle a una función un determinado evento. Cuando ese evento se de, causará una llamada a la función a la que esté ligada, por ejemplo, para el caso de la función ``movimiento_hacia_abajo`` el evento asignado es el "tocar la flecha que apunta hacia abajo del teclado", cuando se lleve a cabo esta acción, la función ``movimiento_hacia_abajo`` será llamada, permitiendo así el movimiento de la nave hacia a abajo cuando se toque esta tecla.
 
 También es importante saber que la función ``renderizacion`` no solo se encarga de renderizar/dibujar en pantalla al jugador, también tiene la tarea de cargar y renderizar los asteroides que aparecen en pantalla, y los "labels" que contienen información importante como el puntaje obtenido, la cantidad de vidas del jugador, el tiempo transcurrido y el nivel en el que se está. En el caso de los asteroides, como la cantidad de estos varía según el nivel, fue necesario implementar un par de condiciones que se encargarán de verificar el nivel en el que se está y con base a ello, cargar la cantidad de asteroides que corresponden al nivel. Por último, pero no menos importante, en el caso de los "labels" no hizo falta poner ninguna condición, pues estas etiquetas se deberán renderizar, por igual, en cada nivel. 

- Función del movimiento de los asteroides:

 La función encargada del movimiento de los obstaculos es el método ``movimiento_asteroides``, que se recibe como argumentos tres cosas: El nivel, que sería un objeto de alguna de las 3 clases de nivel que hay en el que se crearía el nivel como tal. Teniendo este objeto es posible acceder a los asteroides y a los atributos que construyen a estos últimos. La función también recibe la pantalla y el lienzo del nivel sobre el que se está, esto obviamente para lograr que los asteroides se muevan dentro de la pantalla del nivel en el que se está jugando. Cabe resaltar que es función también tiene un par de condiciones que se encargan de verificar el número de nivel en el que se está, pues tal y como se especificó antes, la cantidad de asteroides en pantalla avría según el nivel, y por lo tanto, la cantidad de asteroides a mover también varía. Por último, hay que resaltar que la lógica detrás del código que compone a esta función es exactamente el mismo para todos los asteroides, literalmente, lo único que cambia es el asteroide al que accedemos (puede ser el ``asteroide_1``, el ``asteroide_2``, el ``asteroide_3`` etc.).
 
 __Explicación, movimiento de los asteroides (es la misma lógica para todos los asteroides):__
 
 Después de haber verificado el nivel en el que se está, la función se encarga de ir realizando las operaciones que se encargan de darle movimiento a cada asteroide. El código que permite esto está estructurado de la siguiente manera: Un bloque se encarga de modificar la posición y dirección en el eje "x" que el asteroide lleva, mientras que el otro bloque hace exactamente lo mismo pero para el eje "y". Cabe resaltar que tanto la posición como la dirección de los ejes son atributos propios de la clase "Asteroide", los cuales, dependiendo de las coordenadas en las que el asteroide se encuentre en el momento, se modificarán de una u otra manera. Primero, lo que la función hará será darle una trayectoria base al asteroide, este comenzará a moverse normalmente; mientras el asteroide se mueve, la función va a verificando que la posición actual tanto en el eje "x" como en el eje "y" no exceda los límites establecidos en la condiciones creadas para cada eje. En el momento en el que el asteroide exceda alguno de estos límites, la dirección que el asteroide lleva sobre ese eje cambiará, causando que la cantidad predeterminada de pixeles que el obstaculo se mueve (10 pixeles) se resten o se sumen de la posición en el eje "x" o "y" actual del asteroide, según corresponde. Cabe resaltar que el valor predeterminado de la dirección tanto en el eje "x" como en el "y" es 1, lo que causa que la dirección cambie es el signo delante de ese 1, si el 1 es negativo, entonces, en el caso del eje "x", cuando se multiplique esa dirección con los 10 pixeles que se mueve el asteroide, la cantidad se restará de la posición en el eje "x" (pues es negativa) lo que generará que el asteroide se mueva hacia la izquierda
 
 
 
 ## Resultados
 
