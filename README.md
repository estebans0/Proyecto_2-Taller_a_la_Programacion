# Documentación del segundo proyecto de Taller a la Programación :space_invader::joystick:
## Introducción
La presente sección escrita tiene como objetivo la documentación del segundo proyecto del curso de Taller a la Programación (CE 1102) de la carrera de Ingeniería de Computadores. Dicho proyecto, análogo al primero, consistirá en el desarrollo de un videojuego, la diferencia radica en que, para esta ocasión, el videojuego tendrá como objetivos principales el esquivar una serie de elementos que aparecerán en pantalla y el sobrevivir durante una cantidad de tiempo determinada, evitando a toda costa ser golpeados por los elementos antes mencionados para así alcanzar la máxima puntuación posible. Al igual que para el primer proyecto, la temática del videojuego será el espacio, por lo que los elementos a esquivar estarán representados por asteroides, mientras que el sprite que el jugador controlará será una nave espacial. En cuanto a lo que es el desarrollo del videojuego como tal, nuevamente se hará uso de la biblioteca Tkinter para el desarrollo de la interfaz gráfica; un par de módulos propios del lenguaje de programación de Python que permitan tomar el tiempo ("Time") y que permitan generar números de manera aleatoria ("Random"); y la biblioteca de sonido "mixer" perteneciente al módulo de "Pygame", para la implementación de música y sonidos. Por último, algo a resaltar es que, para esta ocasión, se hará uso del algoritmo de ordenamiento Quicksort, con el cual se administrarán los puntajes obtenidos por el jugador durante sus partidas. 

Esta documentación estará estructurado de la siguiente manera: Sección de códigos importantes, resultados finales, ensayo sobre la importancia de la ética, equidad y el trabajo en equipo y un cronograma en el que se detallará la manera en la que se desarrolló el proyecto. En la primera sección mencionada se incluirán fragmentos de código de importancia para el funcionamiento del videojuego, además de una breve explicación de los mismos, siendo quizá los algoritmos que se encargarán del movimiento tanto del jugador como de los elementos en pantalla y el algoritmo de ordenamiento Quicksort los más importantes de la sección. Para la segunda sección del trabajo se incluirán screenshots del videojuego en funcionamiento, con ello, se mostrarán las mecánicas de juego más importantes, además, estas imágenes estarán complementadas por una explicación sobre la mecánica mostrada. Para la tercera sección mencionada, se redactará un ensayo con una extensión de una página en el que se hablará un poco sobre la importancia de la ética, la equidad y el trabajo en equipo a la hora de ejercer una profesión. Por último, pero no menos importante, se incluirá un cronograma en el que se observará la manera en la que las tareas fueran distribuidas entre los integrantes del grupo con tal de ejemplificar un poco cómo se trabajó y se desarrolló el proyecto. 

## Secciones de código importantes
En esta sección, se explicará el funcionamiento de los métodos fundamentales para la correcta ejecución del videojuego.
### Funciones de movimiento
- Funciones del movimiento de la nave:
  
 __Clase "Jugador"__:
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_derecho(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __derecha__. |
 | movimiento_izquierdo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __izquierda__. |
 | movimiento_arriba(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __arriba__. |
 | movimiento_abajo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __abajo__. |
 
 __Es importante saber que las posiciones sobre los ejes son atributos propios de la clase "Jugador" a los que se accede para poder hacer las sumas o restas, según el caso.__
 
 Los métodos descritos anteriormente trabajan en conjunto con la función ``renderizacion`` que, tal y como su nombre lo indica, se encarga de renderizar o de dibujar sobre el lienzo de la pantalla del nivel (el "canvas" del nivel) al jugador. Dentro de la función ``renderizacion`` se encuentran las siguientes funciones relacionadas al movimiento del jugador:
 
 __Función "renderizacion":__
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_hacia_derecha(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_derecho`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador más los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_derecho``. Luego, dentro de la función ``movimiento_hacia_derecha``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_derecho``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __derecha__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_derecho``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_izquierda(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_izquierdo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_izquierdo``. Luego, dentro de la función ``movimiento_hacia_izquierda``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_izquierdo``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __izquierda__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_izquierdo``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_arriba(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_arriba`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_arriba``. Luego, dentro de la función ``movimiento_hacia_arriba``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_arriba``) que permitirán el movimiento del objeto, en este caso la nave, hacia __arriba__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_arriba``, esta función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_abajo(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_abajo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador más los 10 pixeles introducidos como argumento en la función ``movimiento_abajo``. Luego, dentro de la función ``movimiento_hacia_abajo``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_abajo``) que permitirán el movimiento del objeto, en este caso la nave, hacia __abajo__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_abajo``, el mismo retornará 0, causando que el "sprite" __no se mueva__. |
 
 Note que en las funciones antes descritas, el argumento que estas reciben siempre es el mismo: "event". La biblioteca "Tkinter" nos permite trabajar con eventos que van desde tocar una tecla hasta hacer un "click", con "event" se refiere justamente a ese tipo de eventos. A través del método propio de "Tkinter" ``.bind`` es posible asignarle a una función un determinado evento. Cuando ese evento se de, causará una llamada a la función a la que esté ligada, por ejemplo, para el caso de la función ``movimiento_hacia_abajo`` el evento asignado es el "tocar la flecha que apunta hacia abajo del teclado", cuando se lleve a cabo esta acción, la función ``movimiento_hacia_abajo`` será llamada, permitiendo así el movimiento de la nave hacia a abajo cuando se toque esta tecla.
 
 También es importante saber que la función ``renderizacion`` no solo se encarga de renderizar/dibujar en pantalla al jugador, también tiene la tarea de cargar y renderizar los asteroides que aparecen en pantalla, y los "labels" que contienen información importante como el puntaje obtenido, la cantidad de vidas del jugador, el tiempo transcurrido y el nivel en el que se está. En el caso de los asteroides, como la cantidad de estos varía según el nivel, fue necesario implementar un par de condiciones que se encargarán de verificar el nivel en el que se está y con base a ello, cargar la cantidad de asteroides que corresponden al nivel. Por último, pero no menos importante, en el caso de los "labels" no hizo falta poner ninguna condición, pues estas etiquetas se deberán renderizar, por igual, en cada nivel. 

- Función del movimiento de los asteroides:

 La función encargada del movimiento de los obstaculos es el método ``movimiento_asteroides``, que se recibe como argumentos tres cosas: El nivel, que sería un objeto de alguna de las 3 clases de nivel que hay en el que se crearía el nivel como tal. Teniendo este objeto es posible acceder a los asteroides y a los atributos que construyen a estos últimos. La función también recibe la pantalla y el lienzo del nivel sobre el que se está, esto obviamente para lograr que los asteroides se muevan dentro de la pantalla del nivel en el que se está jugando. Cabe resaltar que es función también tiene un par de condiciones que se encargan de verificar el número de nivel en el que se está, pues tal y como se especificó antes, la cantidad de asteroides en pantalla avría según el nivel, y por lo tanto, la cantidad de asteroides a mover también varía. Por último, hay que resaltar que la lógica detrás del código que compone a esta función es exactamente el mismo para todos los asteroides, literalmente, lo único que cambia es el asteroide al que accedemos (puede ser el ``asteroide_1``, el ``asteroide_2``, el ``asteroide_3`` etc.).
 
 __Explicación, movimiento de los asteroides (es la misma lógica para todos los asteroides):__
 
 Después de haber verificado el nivel en el que se está, la función se encarga de ir realizando las operaciones que se encargan de darle movimiento a cada asteroide. El código que permite esto está estructurado de la siguiente manera: Un bloque se encarga de modificar la posición y dirección en el eje "x" que el asteroide lleva, mientras que el otro bloque hace exactamente lo mismo, pero para el eje "y". Cabe resaltar que tanto la posición como la dirección de los ejes son atributos propios de la clase "Asteroide", los cuales, dependiendo de las coordenadas en las que el asteroide se encuentre en el momento, se modificarán de una u otra manera.
 
 Primero, lo que la función hará será darle una trayectoria base al asteroide, este comenzará a moverse normalmente; mientras el asteroide se mueve, la función va a verificando que la posición actual tanto en el eje "x" como en el eje "y" no exceda los límites establecidos en las condiciones creadas para cada eje. En el momento en el que el asteroide exceda alguno de estos límites, la dirección que el asteroide lleva sobre ese eje cambiará, causando que la cantidad predeterminada de pixeles que el obstáculo se mueve (10 pixeles) se resten o se sumen de la posición en el eje "x" o "y" actual del asteroide, según corresponda, causando así que el asteroide se mueva hacia la derecha, izquierda, arriba o abajo, dependiendo de la posición que se haya modificado y de si se sumó o se restó. Cabe resaltar que el valor predeterminado de la dirección tanto en el eje "x" como en el "y" es 1, lo que causa que la dirección cambie es el signo delante de ese 1. Por ejemplo, si hablamos sobre el movimiento que se da en el eje “x”, si el 1 fuese negativo, entonces, cuando se haga la multiplicación que nos da el valor final que habrá que sumarle o restarle a la posición actual que lleva el asteroide sobre el eje “x”, como el 1 es negativo, entonces, al multiplicar esa dirección por los 10 pixeles que se mueve el asteroide, la cantidad se restará de la posición en el eje "x" (pues por el signo del 1, el producto será negativo) lo que generará que el asteroide se mueva hacia la izquierda, mientras que en el caso del eje “y”, esta resta permitirá el movimiento hacia arriba. Por otro lado, si el 1 fuese positivo, entonces la cantidad de pixeles en lugar de restarse de la posición actual del asteroide, se suman, permitiendo así un movimiento a la derecha (en el caso del eje “x”) y un movimiento hacia abajo (en el caso del eje “y”). Ahora, el movimiento de los asteroides va más allá de esto, pues la trayectoria que la función logra emular no sigue ningún patrón, es completamente aleatoria para todos y cada uno de los asteroides en pantalla.
 
 Básicamente, en el bloque que se encarga del movimiento sobre el eje “x” hay dos condiciones, una que marca el límite máximo al que el asteroide puede llegar por la derecha y otra que marca el límite mínimo al que el asteroide puede llegar por la izquierda. En el caso de la primera condición, si el asteroide excede el límite establecido, entonces la dirección que lleva sobre el eje “x” cambiará a ser -1 para que la nave se comience a mover hacia la izquierda, sin embargo, la dirección que lleva en ese momento sobre el eje “y” cambia, de manera aleatoria, a un número entre 1 y -1 (ambos números obviamente también están incluidos). Esta aleatoriedad se logra gracias al módulo “random”, el cual, a través del método ``random.randint``, permite establecer un rango de números. El método podrá retornar, de manera aleatoria, un número dentro del rango establecido, en el caso de la función de movimiento de los asteroides, como era de esperar, el rango está definido entre -1 y 1, por lo que cuando el asteroide excede el límite establecido por la derecha, aparte de cambiarse la dirección del movimiento horizontal a -1, la dirección del movimiento vertical cambia aleatoriamente, haciendo que el asteroide se pueda mover hacia abajo o hacia arriba de manera aleatoria. Lo mismo ocurre con el límite del lado izquierdo, si el asteroide se pasa de este límite, la dirección que lleva sobre el eje “x” cambia a 1, por lo que el asteroide se comienza a mover hacia la derecha nuevamente, pero la dirección del eje “y” cambia aleatoriamente a un número entre -1 y 1, logrando así el mismo movimiento descrito en líneas anteriores. Para el caso del movimiento sobre el eje “y”, tenemos también dos condiciones que establecen dos límites distintos: Una condición establece el límite máximo al que el asteroide puede llegar por debajo, mientras que la otra establece el límite mínimo al que el asteroide puede llegar por arriba. Si el asteroide excede el límite establecido por abajo, la dirección sobre el eje “y” pasa a ser -1 para que la cantidad de pixeles que el asteroide se mueve se resten de la posición actual en el eje “y” del asteroide para que así este comience a subir. Por otro lado, la dirección que lleva sobre el eje “x” termina tomando un valor aleatorio entre -1 y 1, por lo que el asteroide puede llegar a moverse hacia la derecha o hacia la izquierda, dependiendo del valor que sea retornado por el método ``random.radint``. Lo mismo ocurre para el límite establecido por arriba, si el asteroide se pasa de este límite, la dirección sobre el eje “y” cambia a 1, causando así que la cantidad de pixeles que el asteroide se mueve se sumen, por lo que el asteroide comienza a bajar. A su vez, la dirección que el asteroide lleva en el eje “x” cambia nuevamente a un valor aleatorio entre 1 y -1, causando así que el asteroide se pueda mover hacia la derecha o hacia la izquierda. Ahora, la razón por la que el asteroide puede moverse de manera incluso diagonal es porque todos los bloques de código antes descritos trabajan en conjunto, por lo que el asteroide adquiere la capacidad de emular todo tipo de trayectorias de manera aleatoria. Por último, es importante resaltar que todos y cada uno de los asteroides de los niveles utilizan exactamente el mismo algoritmo para lograr el movimiento aleatorio.
 
 __Función de colisiones:__
 
 La sección de código que se encarga de detectar las colisiones está dividida en seis funciones distintas, mostradas y descritas en la siguiente tabla:
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | asteroide_golpea_jugador(nivel, canvas_nivel) | Esta es la función que se encarga de quitarle un punto de vida al jugador en caso de que se haya detectado una colisión entre la nave y alguno de los asteroides del nivel. Para ello, se implementa una condición inicial en la que se llama a la función ``deteccion_colisiones_gen``, lo que se hace es evaluar si esta función retornó el valor booleano "True", de ser así, se pasará al siguiente bloque de código en el que se hace una simple resta entre la cantidad de vidas del jugador y 1. |
 | deteccion_colisiones_gen(nivel, canvas_nivel) | Esta función es la que se encarga de llamar a las funciones de colisión que se crearon para cada nivel. Recordemos que según el nivel en el que estemos, la cantidad de asteroides varía, por lo que era necesario crear tres funciones distintas en las que la única diferencia es que, dependiendo del nivel, se evalúa una colisión más con respecto al nivel anterior. En resumen, lo único que esta función hace es verificar el nivel en el que se está, y en base a esto, retornar la función correspondiente al nivel. |
 | detect_colisiones(jugador, asteroide) | Esta función se encarga de utilizar las "bboxes" de los dos "sprites", las cuales se obtienen con el método propio del "Tkinter" ``.bbox``, introducidos como argumentos y verificar si alguno de los de los lados que componen la "bbox" de ambos objetos intersecan. Si hubo una intersección, entonces eso quiere decir que hubo una colisión, por lo que la función retornará el valor booleano "True". Cabe resaltar que la función está compuesta por varias condiciones que se encargan de verificar si ocurrió alguno de todos los posibles escenarios que se pueden dar en una colisión, por ejemplo, que el lado derecho de la "bbox" de la nave colisione con la parte izquierda de la "bbox" del asteroide.  |
 | deteccion_colisiones_1(canvas_nivel, nave, obstaculo_1, obstaculo_2, obstaculo_3) | Esta es la función que se encarga de detectar las colisiones para el primer nivel, por lo tanto, solo recibe como argumentos, aparte del canvas/lienzo del nivel, una nave y tres asteroides. |
 | deteccion_colisiones_2(canvas_nivel, nave, obstaculo_1, obstaculo_2, obstaculo_3, obstaculo_4) | Esta es la función que se encarga de detectar las colisiones para el segundo nivel, por lo tanto, solo recibe como argumentos, aparte del canvas/lienzo del nivel, una nave y cuatro asteroides. |
 | deteccion_colisiones_3(canvas_nivel, nave, obstaculo_1, obstaculo_2, obstaculo_3, obstaculo_4, obstaculo_5) | Esta es la función que se encarga de detectar las colisiones para el tercer nivel, por lo tanto, solo recibe como argumentos, aparte del canvas/lienzo del nivel, una nave y cinco asteroides. |
 
 Ahora, se procederá a explicar el funcionamiento de los métodos ``deteccion_colisiones_1``, ``deteccion_colisiones_2`` y ``deteccion_colisiones_3``, funciones las cuales trabajan exactamente igual. Se explicarán estas funciones utilizando como ejemplo la función ``deteccion_colisiones_1``:
 
 Lo que esta función hace es lo siguiente: Primero carga el “sprite” de cada objeto introducido como argumento y determina, haciendo uso del método ``.bbox``, la "bbox" de cada objeto. Una vez tiene la "bbox" de la nave y los 3 asteroides, entonces, dentro de tres variables distintas, se almacena una llamada a la función ``detect_colisiones`` en donde se introduce, como argumentos, todos los posibles escenarios de colisión que se pueden llegar a dar, es decir, una colisión entre la nave y el primer asteroide, una colisión entre la nave y el segundo asteroide y una colisión entre la nave y el tercer asteroide. Después de ello, se definen tres variables de resultado que almacenarán, temporalmente, el valor booleano que la función ``deteccion_colisiones_1`` devolverá después de una evaluación. Inicialmente, cada variable (que equivalen a la cantidad de asteroides que hay en el nivel, pues como se explicaba antes, según el nivel va a haber una u otra cantidad de escenarios de colisión distintos) de resultado almacena el valor “False”, pero, dependiendo del valor booleano que las variables que almacenan las llamadas a la función ``detect_colisiones`` tengan, el valor de las variables de resultado puede cambiar. Ahora, la función ``deteccion_colisiones_1`` tiene tres condiciones para cada posible colisión, esas tres condiciones funcionan exactamente por el mismo algoritmo. Por ejemplo, la función que detecta si hubo una colisión entre la nave y el primer asteroide funciona de la siguiente manera: Primero, evalúa si la variable que almacena la llamada a la función ``detect_colisiones`` obtuvo, como resultado, el valor “True”, si esta variable esta almacenando dicho valor booleano, entonces se pasará a la siguiente condición, la cual evalúa si la fuerza del asteroide está en 1. __Antes de continuar, es importante saber que la fuerza del asteroide es un atributo propio de la clase “Asteroide”, este atributo es como una especie de modo que indica si el asteroide puede dañar o no al jugador; se podría ver como un “modo daño” el cual estará activado únicamente cuando este en 1.__ Si la fuerza del asteroide está en 1, entonces la variable que almacena temporalmente el resultado que indica si hubo colisión o no pasará a almacenar el valor booleano “True”, y a su vez, el atributo fuerza pasará a ser 0, es decir el “modo daño” se habría desactivado. ¿Porqué se desactiva el modo daño? Porque después de que se le resta vida al jugador por haber detectado una colisión, la nave y el asteroide seguirán colisionando por unos cuantos milisegundos, en estos milisegundos, la función se volverá a llamar, por lo que en la variable que evalúa el primer escenario (variable que almacena una llamada a la función ``detect_colisiones`` entre la nave y el asteroide 1) volverá a retornar el valor booleano “True”, por lo que cuando la función ``deteccion_colisiones_1`` vuelva a pasar por la condición correspondiente a este primer escenario de colisión, podrá llegar hasta la última condición, que es la que evalúa si la fuerza está en 1. Como la fuerza continua en 1, entonces, nuevamente, la variable que almacena temporalmente el resultado de la colisión del primer escenario seguirá teniendo el valor booleano “True”, razón por la cual la función ``deteccion_colisiones_1`` volverá a retornar el valor “True”, causando así que la vida del jugador se vuelva a disminuir. En pocas palabras, si no se desactiva el “modo daño”, el jugador perderá sus tres vidas en esos milisegundos, esa es la razón de porqué el atributo fuerza y la condición que evalúa el entero que dicho atributo tiene es tan importante. Así, después de detectar la primera colisión no volverá a quitar vida en esos milisegundos que la nave y el asteroide siguen colisionando. Si bien es cierto que debido a esos milisegundos que la nave y el asteroide siguen colisionando, el valor booleano de la variable que almacena la llamada evaluando a este primer escenario de colisión seguirá siendo “True”, cuando llegue a evaluar si la fuerza está en 1, detectará que este no es el caso, por lo que la variable que almacena el resultado temporalmente no volverá a tener el valor “True” en esos milisegundos, por lo que la función ``deteccion_colisiones_1`` no retornará ese valor, logrando así que no se vuelva a disminuir un punto de vida durante esos milisegundos. Por último, cabe resaltar que cuando ya el primer asteroide y la nave se separan, entonces, la próxima llamada a la función ``detect_colisiones`` que evalúa este escenario, al no detectar ninguna condición, retornará el valor “False”, por lo que cuando la función ``deteccion_colisiones_1`` vuelva a pasar por la condición que evalúa si la variable que almacena la llamada a la función ``detect_colisiones`` con el primer escenario está en “True” no entrará a dicha condición, pasará a un “Else” que lo que hace es reactivar el “modo daño” de ese asteroide para que en la próxima colisión sí pueda quitar vida. Esta lógica es exactamente la misma para cada escenario de colisión, no solo para la función ``deteccion_colisiones_1``, sino también para la función ``deteccion_colisiones_2`` y la función ``deteccion_colisiones_3``. La única diferencia es, por supuesto, la cantidad de asteroides y por lo tanto la cantidad de escenarios de colisión.
 
 __Función “ciclo_juego”:__
 
La función ``ciclo_juego`` es quizá, la función más importante del código, pues es la función de llevar a cabo, tal y como lo dice su nombre, el ciclo del juego. Esta función tiene tres funciones anidadas: La función ``renderizacion``, la función ``actualizar_juego`` y la función ``continua_juego``. Se podría decir que lo principal en esta función es el método ``continua_juego``, pues este método es el que se encarga de evaluar si juego continua, si el juego se perdió o si el juego se ganó, en pocas palabras, esta función es la que indica si el ciclo del juego se debe seguir repitiendo o no.  La función ``continua_juego`` se resume a tres condiciones: Si la vida del jugador es menor o igual a 0, retornará un -1 (el jugador perdió); si la función ``cronometro``, que es la función encargada de contar la cantidad de segundos transcurridos, es igual a 60, entonces retornará un 1 (el jugador ganó la partida); y si no se cumple ninguna de las dos condiciones anteriores, entonces retornará un 0 (la partida continua). Ahora, es importante saber que en la función ``ciclo_juego`` se tiene una variable de nombre “continuar” dentro de la cual se hace una llamada a la función ``continua_juego``, por lo tanto, esta variable, dependiendo de lo que esté pasando en la partida, puede almacenar un 0, un 1 y un -1. Estos números se necesitan para que las condiciones escritas en la función ``ciclo_juego`` puedan realizar unas comparaciones que decidirán si el ciclo se continúa repitiendo, si se muestra el “frame” de victoria o si se muestra el “frame” de “perdiste”. Si la variable “continuar” almacena un 0, entonces se hará una nueva llamada a la función ``ciclo_juego`` para que la partida se siga actualizando y renderizando. Si la variable “continuar” almacena un -1, entonces se dejará de llamar a la función ``ciclo_juego``, por lo que toda la acción en pantalla se detendrá y el nivel se dejará de actualizar y renderizar para posteriormente mostrar el “frame” de “perdiste”. Por otro lado, si la variable “continuar” almacena un 1, entonces ocurrirá exactamente lo mismo que cuando la variable almacena un -1, con la única diferencia de que el “frame” que se mostrará será el de victoria. Ahora, evidentemente el caso más importante es el del 0, ¿Qué ocurre cuando la variable “continuar” almacena un 0? Como se explicaba en líneas anteriores, la función ``ciclo_juego`` tiene tres funciones, por lo tanto, la variable “continuar” almacena un cero y la función ``ciclo_juego`` se vuelve a llamar, también se están volviendo a llamar a las tres funciones que antes se mencionaban, es decir, la función ``renderizacion`` continuará renderizando el movimiento del jugador, la función ``actualizar_juego``, que es una función únicamente compuesta por otros métodos, específicamente por los siguientes: La función ``movimiento_asteroides``, por la función ``asteroide_golpea_jugador`` , por la función ``actualiza_puntaje``  y por la función ``actualiza_labels``, continuará actualizando y llevando a cabo el movimiento de los asteroides, la verificación de colisiones entre la nave y los asteroides del nivel, la actualización de la información que el atributo “puntaje” del nivel almacena (función ``actualiza_puntaje``) y la actualización, en tiempo real, de la información que los “labels” de la pantalla de nivel muestran (“labels” de tiempo restante, de vidas del jugador y de puntaje). En resumen, la función ``ciclo_juego`` es la que lleva a cabo todo lo que ocurre en el nivel y durante la partida.     

 

 ## Resultados
 
