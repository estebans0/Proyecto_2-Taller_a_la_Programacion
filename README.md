# Documentación del segundo proyecto de Taller a la Programación :space_invader::joystick:
## Introducción
La presente sección escrita tiene como objetivo la documentación del segundo proyecto del curso de Taller a la Programación (CE 1102) de la carrera de Ingeniería de Computadores. Dicho proyecto, análogo al primero, consistirá en el desarrollo de un videojuego, la diferencia radica en que, para esta ocasión, el videojuego tendrá como objetivos principales el esquivar una serie de elementos que aparecerán en pantalla y el sobrevivir durante una cantidad de tiempo determinada, evitando a toda costa ser golpeados por los elementos antes mencionados para así alcanzar la máxima puntuación posible. Al igual que para el primer proyecto, la temática del videojuego será el espacio, por lo que los elementos a esquivar estarán representados por asteroides, mientras que el sprite que el jugador controlará será una nave espacial. En cuanto a lo que es el desarrollo del videojuego como tal, nuevamente se hará uso de la biblioteca Tkinter para el desarrollo de la interfaz gráfica; un par de módulos propios del lenguaje de programación de Python que permitan tomar el tiempo ("Time") y que permitan generar números de manera aleatoria ("Random"); y la biblioteca de sonido "mixer" perteneciente al módulo de "Pygame", para la implementación de música y sonidos. Por último, algo a resaltar es que, para esta ocasión, se hará uso del algoritmo de ordenamiento Quicksort, con el cual se administrarán los puntajes obtenidos por el jugador durante sus partidas. 

Esta documentación estará estructurado de la siguiente manera: Sección de códigos importantes, resultados finales, ensayo sobre la importancia de la ética, equidad y el trabajo en equipo y un cronograma en el que se detallará la manera en la que se desarrolló el proyecto. En la primera sección mencionada se incluirán fragmentos de código de importancia para el funcionamiento del videojuego, además de una breve explicación de los mismos, siendo quizá los algoritmos que se encargarán del movimiento tanto del jugador como de los elementos en pantalla y el algoritmo de ordenamiento Quicksort los más importantes de la sección. Para la segunda sección del trabajo se incluirán screenshots del videojuego en funcionamiento, con ello, se mostrarán las mecánicas de juego más importantes, además, estas imágenes estarán complementadas por una explicación sobre la mecánica mostrada. Para la tercera sección mencionada, se redactará un ensayo con una extensión de una página en el que se hablará un poco sobre la importancia de la ética, la equidad y el trabajo en equipo a la hora de ejercer una profesión. Por último, pero no menos importante, se incluirá un cronograma en el que se observará la manera en la que las tareas fueran distribuidas entre los integrantes del grupo con tal de ejemplificar un poco cómo se trabajó y se desarrolló el proyecto. 

## Secciones de código importantes
En esta sección, se explicará el funcionamiento de los métodos fundamentales para la correcta ejecución del videojuego.
### Funciones de movimiento
- Funciones del movimiento de la nave:
  
 __Clase "Jugador"__:
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_derecho(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __derecha__. |
 | movimiento_izquierdo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "x" del jugador, permitiendo así el movimiento hacia la __izquierda__. |
 | movimiento_arriba(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le restará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __arriba__. |
 | movimiento_abajo(pixeles) | Método perteneciente a la clase "Jugador". Establece un límite, a través de una condición, que evita que el jugador se mueva después de sobrepasar cierta cantidad de pixeles. Si el jugador todavía está dentro del límite, entonces la cantidad de pixeles especificada como argumento (10 pixeles) se le sumará a la posición actual en el eje "y" del jugador, permitiendo así el movimiento hacia __abajo__. |
 
 __Es importante saber que las posiciones sobre los ejes son atributos propios de la clase "Jugador" a los que se accede para poder hacer las sumas o restas, según el caso.__
 
 Los métodos descritos anteriormente trabajan en conjunto con la función ``renderizacion`` que, tal y como su nombre lo indica, se encarga de renderizar o de dibujar sobre el lienzo de la pantalla del nivel (el "canvas" del nivel) al jugador. Dentro de la función ``renderizacion`` se encuentran las siguientes funciones relacionadas al movimiento del jugador:
 
 __Función "renderizacion":__
 | __Nombre de la función__ | __Descripción__ |
 | -------------------------- | ----------------- |
 | movimiento_hacia_derecha(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_derecho`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador más los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_derecho``. Luego, dentro de la función ``movimiento_hacia_derecha``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_derecho``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __derecha__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_derecho``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_izquierda(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "y" (que se mantiene en cero) y una variable "x", dentro de la cual se hace una llamada a la función ``movimiento_izquierdo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "x" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_izquierdo``. Luego, dentro de la función ``movimiento_hacia_izquierda``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" (la cual tendrá el valor dado por la función ``movimiento_izquierdo``) y una coordenada "y" que permitirán el movimiento del objeto, en este caso la nave, hacia la  __izquierda__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_izquierdo``, la función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_arriba(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_arriba`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador menos los 10 pixeles introducidos como argumento en la llamada a la función ``movimiento_arriba``. Luego, dentro de la función ``movimiento_hacia_arriba``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_arriba``) que permitirán el movimiento del objeto, en este caso la nave, hacia __arriba__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_arriba``, esta función retornará 0, causando que el "sprite" __no se mueva__. |
 | movimiento_hacia_abajo(event) | Método perteneciente a la función "Renderizacion". Esta función tiene dos variables, una variable "x" (que se mantiene en cero) y una variable "y", dentro de la cual se hace una llamada a la función ``movimiento_abajo`` que se encargará de evaluar si el jugador está dentro del límite. Si es el caso, la función devolverá la posición actual en el eje "y" del jugador más los 10 pixeles introducidos como argumento en la función ``movimiento_abajo``. Luego, dentro de la función ``movimiento_hacia_abajo``, hay un método propio del "Tkinter" llamado ``.move`` al cual se le da, antes del punto, el lienzo de la pantalla sobre la que se moverá la nave, y además, como argumentos, el "sprite" de la nave, una coordenada "x" y una coordenada "y" (la cual tendrá el valor dado por la función ``movimiento_abajo``) que permitirán el movimiento del objeto, en este caso la nave, hacia __abajo__. En caso de que el jugador se pase del límite establecido en el método ``movimiento_abajo``, el mismo retornará 0, causando que el "sprite" __no se mueva__. |
 
 Note que en las funciones antes descritas, el argumento que estas reciben siempre es el mismo: "event". La biblioteca "Tkinter" nos permite trabajar con eventos que van desde tocar una tecla hasta hacer un "click", con "event" se refiere justamente a ese tipo de eventos. A través del método propio de "Tkinter" ``.bind`` es posible asignarle a una función un determinado evento. Cuando ese evento se de, causará una llamada a la función a la que esté ligada, por ejemplo, para el caso de la función ``movimiento_hacia_abajo`` el evento asignado es el "tocar la flecha que apunta hacia abajo del teclado", cuando se lleve a cabo esta acción, la función ``movimiento_hacia_abajo`` será llamada, permitiendo así el movimiento de la nave hacia a abajo cuando se toque esta tecla.
 
 También es importante saber que la función ``renderizacion`` no solo se encarga de renderizar/dibujar en pantalla a la jugador, también tiene la tarea de cargar y renderizar los asteroides que aparecen en pantalla, y los "labels" que contienen información importante como el puntaje obtenido, la cantidad de vidas del jugador, el tiempo transcurrido y el nivel en el que se está. En el caso de losa steroides, como la cantidad de estos varía según el nivel, fue necesario implementar un par de condiciones que se encargarán de verificar el nivel en el que se está y con base a ello, cargar la cantidad de asteroides que corresponde al nivel. Por último, pero no menos importante, en el caso de los "labels" no hizo falta poner ninguna condición, pues estas etiquetas se deberán renderizar, por igual, en cada nivel. 

- Función del movimiento de los asteroides:

 A simple vista, la función ``movimiento_asteroides`` se puede ver 
 
 ## Resultados
 
